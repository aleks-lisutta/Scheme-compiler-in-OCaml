;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 32

section .data
const_tbl:
db T_VOID
db T_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "mary"
MAKE_LITERAL_SYMBOL(6)
MAKE_LITERAL_STRING "had"
MAKE_LITERAL_SYMBOL(28)
MAKE_LITERAL_STRING "a"
MAKE_LITERAL_SYMBOL(49)
MAKE_LITERAL_STRING "little"
MAKE_LITERAL_SYMBOL(68)
MAKE_LITERAL_STRING "lambda"
MAKE_LITERAL_SYMBOL(92)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+56], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+64], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+72], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+136], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+192], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+224], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+208], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+232], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+240], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+248], rax

user_code_fragment:

;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
push SOB_NIL_ADDRESS
  ;;magic

mov rax, qword const_tbl+107
push rax

mov rax, qword const_tbl+83
push rax

mov rax, qword const_tbl+59
push rax

mov rax, qword const_tbl+40
push rax

mov rax, qword const_tbl+19
push rax

push 6
             
            mov rax, 0
	        cmp rax,0
	        jne dep_0_1
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_1
	        dep_0_1:
	        lea rax, [(0+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 0
	        mov rdx, rax
	        PUSH_ARGS

            test_1:


            MAKE_CLOSURE(rax,rax,code1)        
            jmp end_code1               ;; lambda

            code1:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt1
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in1:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt1             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp1
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args1:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args1 ;;lambda

only_n_env_ret_rbp1:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt1:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 1
	        cmp rax,0
	        jne dep_0_2
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_2
	        dep_0_2:
	        lea rax, [(1+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 1
	        mov rdx, rax
	        PUSH_ARGS

            test_2:


            MAKE_CLOSURE(rax,rax,code2)        
            jmp end_code2               ;; lambda

            code2:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt2
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in2:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt2             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp2
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args2:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args2 ;;lambda

only_n_env_ret_rbp2:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt2:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 2
	        cmp rax,0
	        jne dep_0_3
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_3
	        dep_0_3:
	        lea rax, [(2+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 2
	        mov rdx, rax
	        PUSH_ARGS

            test_3:


            MAKE_CLOSURE(rax,rax,code3)        
            jmp end_code3               ;; lambda

            code3:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt3
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in3:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt3             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp3
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args3:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args3 ;;lambda

only_n_env_ret_rbp3:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt3:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 3
	        cmp rax,0
	        jne dep_0_4
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_4
	        dep_0_4:
	        lea rax, [(3+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 3
	        mov rdx, rax
	        PUSH_ARGS

            test_4:


            MAKE_CLOSURE(rax,rax,code4)        
            jmp end_code4               ;; lambda

            code4:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt4
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in4:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt4             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp4
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args4:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args4 ;;lambda

only_n_env_ret_rbp4:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt4:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 4
	        cmp rax,0
	        jne dep_0_5
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_5
	        dep_0_5:
	        lea rax, [(4+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 4
	        mov rdx, rax
	        PUSH_ARGS

            test_5:


            MAKE_CLOSURE(rax,rax,code5)        
            jmp end_code5               ;; lambda

            code5:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt5
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in5:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt5             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp5
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args5:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args5 ;;lambda

only_n_env_ret_rbp5:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt5:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 5
	        cmp rax,0
	        jne dep_0_6
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_6
	        dep_0_6:
	        lea rax, [(5+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 5
	        mov rdx, rax
	        PUSH_ARGS

            test_6:


            MAKE_CLOSURE(rax,rax,code6)        
            jmp end_code6               ;; lambda

            code6:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt6
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in6:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt6             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp6
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args6:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args6 ;;lambda

only_n_env_ret_rbp6:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt6:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 6
	        cmp rax,0
	        jne dep_0_7
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_7
	        dep_0_7:
	        lea rax, [(6+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 6
	        mov rdx, rax
	        PUSH_ARGS

            test_7:


            MAKE_CLOSURE(rax,rax,code7)        
            jmp end_code7               ;; lambda

            code7:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt7
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in7:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt7             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp7
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args7:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args7 ;;lambda

only_n_env_ret_rbp7:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt7:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 7
	        cmp rax,0
	        jne dep_0_8
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_8
	        dep_0_8:
	        lea rax, [(7+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 7
	        mov rdx, rax
	        PUSH_ARGS

            test_8:


            MAKE_CLOSURE(rax,rax,code8)        
            jmp end_code8               ;; lambda

            code8:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt8
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in8:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt8             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp8
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args8:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args8 ;;lambda

only_n_env_ret_rbp8:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt8:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 8
	        cmp rax,0
	        jne dep_0_9
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_9
	        dep_0_9:
	        lea rax, [(8+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 8
	        mov rdx, rax
	        PUSH_ARGS

            test_9:


            MAKE_CLOSURE(rax,rax,code9)        
            jmp end_code9               ;; lambda

            code9:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt9
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in9:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt9             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp9
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args9:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args9 ;;lambda

only_n_env_ret_rbp9:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt9:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 9
	        cmp rax,0
	        jne dep_0_10
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_10
	        dep_0_10:
	        lea rax, [(9+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 9
	        mov rdx, rax
	        PUSH_ARGS

            test_10:


            MAKE_CLOSURE(rax,rax,code10)        
            jmp end_code10               ;; lambda

            code10:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt10
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in10:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt10             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp10
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args10:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args10 ;;lambda

only_n_env_ret_rbp10:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt10:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 10
	        cmp rax,0
	        jne dep_0_11
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_11
	        dep_0_11:
	        lea rax, [(10+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 10
	        mov rdx, rax
	        PUSH_ARGS

            test_11:


            MAKE_CLOSURE(rax,rax,code11)        
            jmp end_code11               ;; lambda

            code11:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt11
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in11:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt11             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp11
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args11:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args11 ;;lambda

only_n_env_ret_rbp11:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt11:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 11
	        cmp rax,0
	        jne dep_0_12
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_12
	        dep_0_12:
	        lea rax, [(11+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 11
	        mov rdx, rax
	        PUSH_ARGS

            test_12:


            MAKE_CLOSURE(rax,rax,code12)        
            jmp end_code12               ;; lambda

            code12:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt12
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in12:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt12             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp12
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args12:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args12 ;;lambda

only_n_env_ret_rbp12:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt12:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 12
	        cmp rax,0
	        jne dep_0_13
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_13
	        dep_0_13:
	        lea rax, [(12+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 12
	        mov rdx, rax
	        PUSH_ARGS

            test_13:


            MAKE_CLOSURE(rax,rax,code13)        
            jmp end_code13               ;; lambda

            code13:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt13
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in13:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt13             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp13
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args13:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args13 ;;lambda

only_n_env_ret_rbp13:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt13:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 13
	        cmp rax,0
	        jne dep_0_14
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_14
	        dep_0_14:
	        lea rax, [(13+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 13
	        mov rdx, rax
	        PUSH_ARGS

            test_14:


            MAKE_CLOSURE(rax,rax,code14)        
            jmp end_code14               ;; lambda

            code14:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt14
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in14:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt14             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp14
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args14:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args14 ;;lambda

only_n_env_ret_rbp14:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt14:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 14
	        cmp rax,0
	        jne dep_0_15
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_15
	        dep_0_15:
	        lea rax, [(14+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 14
	        mov rdx, rax
	        PUSH_ARGS

            test_15:


            MAKE_CLOSURE(rax,rax,code15)        
            jmp end_code15               ;; lambda

            code15:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt15
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in15:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt15             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp15
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args15:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args15 ;;lambda

only_n_env_ret_rbp15:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt15:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 15
	        cmp rax,0
	        jne dep_0_16
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_16
	        dep_0_16:
	        lea rax, [(15+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 15
	        mov rdx, rax
	        PUSH_ARGS

            test_16:


            MAKE_CLOSURE(rax,rax,code16)        
            jmp end_code16               ;; lambda

            code16:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt16
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in16:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt16             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp16
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args16:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args16 ;;lambda

only_n_env_ret_rbp16:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt16:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 16
	        cmp rax,0
	        jne dep_0_17
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_17
	        dep_0_17:
	        lea rax, [(16+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 16
	        mov rdx, rax
	        PUSH_ARGS

            test_17:


            MAKE_CLOSURE(rax,rax,code17)        
            jmp end_code17               ;; lambda

            code17:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt17
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in17:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt17             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp17
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args17:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args17 ;;lambda

only_n_env_ret_rbp17:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt17:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 17
	        cmp rax,0
	        jne dep_0_18
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_18
	        dep_0_18:
	        lea rax, [(17+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 17
	        mov rdx, rax
	        PUSH_ARGS

            test_18:


            MAKE_CLOSURE(rax,rax,code18)        
            jmp end_code18               ;; lambda

            code18:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt18
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in18:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt18             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp18
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args18:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args18 ;;lambda

only_n_env_ret_rbp18:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt18:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 18
	        cmp rax,0
	        jne dep_0_19
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_19
	        dep_0_19:
	        lea rax, [(18+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 18
	        mov rdx, rax
	        PUSH_ARGS

            test_19:


            MAKE_CLOSURE(rax,rax,code19)        
            jmp end_code19               ;; lambda

            code19:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt19
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in19:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt19             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp19
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args19:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args19 ;;lambda

only_n_env_ret_rbp19:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt19:
              ;;lambda
            push SOB_NIL_ADDRESS
  ;;magic

mov rax, PVAR(0)
push rax

push 2
             
            mov rax, 19
	        cmp rax,0
	        jne dep_0_20
	        MALLOC rax,8
	        mov qword [rax], SOB_NIL_ADDRESS
	        jmp test_20
	        dep_0_20:
	        lea rax, [(19+1)*WORD_SIZE]
	        MALLOC rax, rax
	        mov rcx, qword [rbp+2*8]
	        COPY_ENV rcx, rax, 19
	        mov rdx, rax
	        PUSH_ARGS

            test_20:


            MAKE_CLOSURE(rax,rax,code20)        
            jmp end_code20               ;; lambda

            code20:                        ;; lambda 
            push rbp
            mov rbp,rsp


            mov rcx,[rbp+WORD_SIZE*3] ;;rcx=n 
            sub rcx, 0 ;;rcx=n-(length of args)      
            dec rcx
            cmp rcx,0

            je noOpt20
                                ;;;; lambda
            

            lea rdx, [(4+0)*WORD_SIZE+rbp]  ;;len
            MAKE_LIST rax, rcx, rdx


loop_in20:                              ;;lambda

            lea rbx, [rbp+3*WORD_SIZE]

            mov rcx,qword [rbp+3*8] ;; rcx=n
            dec rcx
            lea rcx, [rbx+WORD_SIZE*rcx]
            mov qword [rcx], rax


            mov rdx,qword [rbp+3*8]
            sub rdx, 0             ;;len
            sub rdx, 2


            mov rcx, 0              ;;len

            cmp rdx, 0
            jle noOpt20             ;;lambda

            cmp rcx,0
            je only_n_env_ret_rbp20
            lea rbx, [rbp+4*WORD_SIZE]

    loop_args20:             ;;lambda
            dec rcx
            lea r10, [rbx+WORD_SIZE*rcx]

            lea r11, [r10+WORD_SIZE*rdx]
            mov r10, qword [r10]
            mov qword [r11],r10   
            cmp rcx,0
            jne loop_args20 ;;lambda

only_n_env_ret_rbp20:
            lea rax, [rbp+WORD_SIZE*(3+rdx)]
            mov r12, 0+2
            mov qword [rax],r12              ;;len
            
            sub rax,8
            mov rbx, qword [rbp+2*8]
            mov qword [rax] ,rbx
            
            sub rax,8
            mov rbx,qword [rbp+1*8]
            mov qword [rax] ,rbx

            sub rax,8
            mov rbx,qword [rbp]
            mov qword [rax] ,rbx

            mov rbp,    rax
            mov rsp,    rbp

            noOpt20:
              ;;lambda
            mov rax, PVAR(0)
                ;;body
            leave

            ret

            end_code20:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code19:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code18:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code17:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code16:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code15:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code14:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code13:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code12:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code11:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code10:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code9:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code8:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code7:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code6:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code5:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code4:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code3:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code2:
           ;; lambda
            

             mov r9, PARAM_COUNT
             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             push qword [rbp+WORD_SIZE*1]
             push qword [rbp]
             YAKI_SHIFT_FRAME 6
             pop rbp
             lea rsp ,[rsp + 8*(r9+4)]
             jmp rax

                ;;body
            leave

            ret

            end_code1:
           ;; lambda
            

             CLOSURE_ENV rbx, rax
             push rbx
             CLOSURE_CODE rax, rax
             call rax
add rsp , 8*1 

            pop rbx

            lea rsp , [rsp + 8* rbx]
	call write_sob_if_not_void
  check:
  ;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	
      CAR rax, rsi
      
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	
      CDR rax, rsi
      
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	
    MAKE_PAIR(rax,rsi,rdi)
    
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	
        CAR rsi, rsi
        mov [rsi], rdi
        mov rax, SOB_VOID_ADDRESS
        
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	
        CDR rsi, rsi
        mov [rsi], rdi
        mov rax, SOB_VOID_ADDRESS
        
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
        
      MAKE_APPLY 1
         pop rbp
         ret